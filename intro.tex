
\noindent{\bf BEGIN Ganesh}

Debugging high performance computing code
remains a challenge at all levels of scale.
%
Conventional HPC debuggers~\cite{allinea-ddt,roguewave,others}
excel at many tasks such as examining the execution
state of a complex simulation at a detailed
level and allowing the developer to re-execute
the program close to the point of failure.
%
However, they do not provide a good understanding
of why a program version that worked earlier
failed upon upgrade or feature addition.
%
Innovative solutions are needed to highlight the
salient differences between two executions in a manner
that makes debugging easier as well as more systematic.
%
A recent study conducted under the auspices of the
DOE~\cite{DBLP:journals/corr/GopalakrishnanH17}
provides a comprehensive survey
of existing debugging tools.
%
It classifies them under
four software organizations (serial, multithreaded,
multi-process, and hybrid), six
method types (formal methods, static analysis, dynamic
analysis, nondeterminism control, anomaly detection,
and parallel debugging), and lists a total of 30 specific
tools.


Despite this abundance of activity and tools, many
significant problems remain to be solved before debugging
{\em can be approached by the HPC community as a collaborative
activity} so that HPC developers can share their solutions
and extend a common framework.
%
Almost all debugging approaches seek to find outliers (``unexpected
executions'') amongst thousands of running processes and threads.
%
The approach taken by most existing tools is to
look for symptoms in a specific bug-class that they cover.
%
Unfortunately,
this approach calls for a programmer having a good guess of what
the underlying problem might be,
and to then pick the right set of tools to deploy.
%
If the guess is wrong, the programmer has no choice but to
refine their guess
and look for bugs in another class,
re-executing the application and hoping for
better luck with another tool.
%
This iterative loop of re-execution followed by applying a
best-guess tool for the suspected bug class can potentially consume
large amounts of execution cycles and also waste an
expert developer's time.
%
More glaring is the fact that these tools must recreate the
execution traces yet again: they do not have means to hand-off
these traces to another tool, or cooperate in symbiotic ways.



It is clear that we cannot collect all relevant pieces of information
necessary to detect all possible bug classes in HPC ranging
across resource leak bugs,  deadlocks, and data races.
%
Each such bug requires its own attributes to be kept.
%
Also, it is clear that debugging is not fully automatable (it is
an undecidable problem in general) and must involve human thinking:
at least to reconcile what is observed against the deeper application
level semantics.
%
However, (1)~we believe that it is still possible to collect one common form
of information and use it to make an initial triage in such
a way that it can guide a later deeper debugging phase to locate
which of the finer bug gradations of bugs (resource leaks or races) brought
an application down.
%
Also, (2)~we believe that it is possible to engage the human {\em with respect
to understanding structured presentations of information}---and not a general
disorienting bug situation.


In our effort, we address both these issues.
%
The common form of information we use is a {\em whole program
function call trace} collected per process/thread.
%
In this paper we build a framework called DiffTrace which relies on
novel ways to diff a normal trace and a fault-laden trace to guide the
debugging engineer closer to the bug.
%
While our work has not (yet) addressed the situations in
which millions of threads and thousands of processes run
for days and produce an error,
we strongly believe that we can get there only 
after we understand the pros and cons of our initial
implementation of the  DiffTrace tool (via this paper).
%
The second problem is handled in DiffTrace by offering a novel
collection of modalities for understanding program execution diffs.
%
We now elaborate on these points by stating three specific
problems we address in this paper.



\paragraph{Problem-1: Collecting Whole-Program {\em Heterogeneous} Function Call Traces
Efficiently:\/} Not only must we have the ability
to record function calls and returns at one
API such as MPI, increasingly we must collect calls/returns at multiple
interfaces (e.g., OpenMP, PThreads, and even inner levels such as TCP).
%
The growing use of heterogeneous programming necessitates that we have
an understanding of MPI and OpenMP activities (for example) to locate cross-API
bugs that are often missed by other tools.
%
Sometimes, these APIs are realized on newer machines, and may contain the
actual error (not the user code itself), and it would be attractive to have
this ability as well.





\noindent{\em Solution to Problem-1:\/}
In DiffTrace, we choose PIN-based whole program binary tracing, with
tracing filters that allow the designer to collect a suitable mixture of API
calls/returns.
%
We realize this facility using
ParLoT, a tool designed by us and published earlier~\cite{parlot-paper}.
%
In our research, we have thus far demonstrated the advantage of
ParLoT with respect to collecting both MPI and OpenMP traces
from a {\em single run of a hybrid MPI/OpenMP program}.
%
We demonstrate that from this single type of traces, it is possible
to pick out MPI-level bugs or OpenMP-level bugs.
%
While this approach to whole-program tracing
may sound extremely computation intensive, we employ
novel on-the-fly compression techniques within ParLoT.
%
We achieve compression efficiencies exceeding 16,000~\cite{parlot-paper},
thus making this technique much more practical, demanding
only a few kilobytes per second of extra bandwidth from the upper levels of
the memory hierarchy.


\paragraph{Problem-2: Need to Generalize Approaches for Outlier Detection:\/}
Given that outlier detection is central to debugging,
it is important to be employing efficient representations of the traces
collected from threads and processes so that one can compute
{\em distances} between these traces more systematically, without
involving human reasoning in the loop.
%
The representation must also be versatile enough to
be able to ``Diff'' the traces\footnote{Hence the name of our tool, {\bf DiffTrace}.}
with respect to {\em an extensible number of vantage points}.
%
These vantage points could be diffing with respect to process level activities,
diffing with respect to thread-level activities, a combination thereof,
or even finite sequences of process/thread calls (say, to locate {\em changes}
in caller/callee relationships).


\noindent{\em Solution to Problem-2: Use of Concept Lattices in Debugging:\/}
In DiffTrace, we employ {\em concept lattices} to amalgamate the collected traces.
%
Concept lattices have previously been employed in HPC to perform structural
clustering of process behaviors~\cite{weber-cl} to present performance data more
meaningfully to users.
%
The authors of that paper employ the notion of {\em Jaccard distances}
to cluster performance results that are closely related to process structures
(determined based on caller/callee relationships).


In DiffTrace, we employ incremental algorithms for building and maintaining
concept lattices from the ParLoT-collected traces.
%
In addition to Jaccard distances, in our work we also perform hierarchical
clustering of traces and provide a tunable threshold for outlier detection.
%
We believe that these uses of concept lattices and more refinement approaches
for outlier detection are new in HPC debugging.


\paragraph{Problem-3: Loop Detection:\/}
Most programs spend most of their time in loops.
%
Therefore it is important to employ state-of-the-art algorithms for
loop extraction from execution traces.
%
It is also important
to be able to diff two executions with respect to changes in their looping behaviors.

\noindent{\em Solution to Problem-3: Rigorous Approaches to Loop Analysis:\/}
In DiffTrace, we employ the notion of NLRs (what does it stand for?) for
extracting loops.
%
Each repetitive loop structure is given an identifier, and nested loops are
expressed as repetitions of this identifier exponentiated (as with regular
expressions).
%
This approach to summarizing loops can help manifest
bugs where the program does not hang or crash, but nevertheless
run differently in a manner that informs the developer engaged in debugging.


\noindent To summarize, the key contributions of this paper are the following [[fix the section numbers
later]]:

\begin{itemize}
\item A method to organize function call traces collected from processes and
      threads into concept lattices, and a method to
      detect loops from dynamic traces (Section~\ref{sec3}).

\item Details of the algorithms employed in DiffTrace (Section~\ref{sec4}).

\item Experimental studies on a heterogeneous program called
      Iterated Local Champion Search (ILCS, Section~\ref{sec5}).

\item Strengths and limitations of DiffTrace, plans for future work (Section~\ref{sec6}).
\end{itemize}



\noindent{\bf END Ganesh}

\hl{[[Ganesh and Saeed have written some text before for the intro which is available in v0/intro.tex (also available but commented in current file). Current version is based on our discussion on May 8th]]}

\begin{itemize}
	\item Importance of whole program diffing : understand changes, debug (DOE REPORT \cite{hpcdoe})
	\item Efficient tracing supports selective monitoring at multiple levels
	\begin{itemize}
		\item Bugs not there at a predictable API level
		\item Prior work (ParLoT) supports whole program tr.
	\end{itemize}
	\item Dissimilarity is important to know: bugs, changes during porting,...
	\item Key enablers of meaningful diffing:
	\begin{itemize}
		\item Formal concepts (novel contrib to debugging)
		\item Loop detection (loop diffing can help)
	\end{itemize}
	\item Importance, given the growing heterogeneity
\end{itemize}


%When a new version of an HPC software system is created, logical errors often get introduced.
%
%To maintain productivity, designers need effective and efficient methods to locate these errors.
%
%Given the increasing use of hybrid (MPI + X) codes and library functions, errors may be introduced through a usage contract violation at multiple interfaces.
%
%Therefore, tools that can record activities at all involved APIs are necessary.
%
%Designers find most of these bugs manually, and the efficacy of a debugging tool is often measured by how well it can highlight the salient differences between the executions of two versions of software.
%
%Given the huge number of things that could be different -- individual iterative patterns of function calls, groups of functions calls, or even specific instruction types (e.g., non-vectorized versus vectorized floating-point dot vector loops) -- designers cannot afford to rerun the application many times to collect each facet of behavior separately.
%
%These issues are well summarized in many recent studies \cite{hpcdoe}


%One of the major challenges of HPC debugging is the huge diversity of applications, which encompass domains such as computational chemistry, molecular dynamics, and climate simulation.
%
%In addition, there are many types of possible “bugs” or, more precisely, errors. An \textbf{error} may be a deadlock or a resource leak. These errors may be caused by different \textbf{faults}: an unexpected message reordering rule (for a deadlock) or a forgotten free statement (for a resource leak).
%
%There exists a collection of scenarios in which a bug can be introduced: when developing a brand-new application, optimizing an existing application, upscaling an application, porting to a new platform, changing the compiler, or even changing compiler flags.
%
%Unlike traditional software, there are hardly any bug-repositories, collection of trace data or debugging-purpose benchmarks in the HPC community.
%
%The heterogeneous nature of HPC bugs makes developers come up with their own solutions to resolve specific classes of bugs on specific architectures or platforms that are not usable elsewhere \cite{hpcdoe}.

% Why we need always on tracing
%When a failure occurs (e.g., a deadlock or crash) or the application outputs an unexpected result, it is not economic to rerun the application and consume resources to reproduce the failure. Moreover, HPC bugs might not be reproducible due to non-deterministic behavior, which is common in HPC applications. Also, the failure might be caused by a bug present at different APIs, system levels or the network, thus multiple reruns might be needed to locate the bug.

%ParLOT introduction
%In previous work \cite{parlot}, we have introduced ParLOT, a tool that efficiently collects whole program function-call traces using dynamic binary instrumentation.
%
%ParLOT captures function calls and returns at different levels (e.g., application and library code) and incrementally compress them on-the-fly, resulting in low runtime overhead and low tracing bandwidth, preserving the whole-program dynamic behavior for offline analysis.
%

% Post-mortem analysis to obtain understanding about different aspects of the dynamic behavior
%In the current work, we introduce DiffTrace, a tool-chain for the post-mortem analysis of \textit{ParLOT Traces} (PTs) that supplies developers with information about dynamic behavior of HPC applications at different levels with different granularities towards debugging. 
%
%The topology of HPC tasks on both distributed and shared memory often follows a ``symmetric'' flow of control such as SPMD, master/slave, or odd/even where multiple tasks contain \textit{similar} events in their control flow.
%
%HPC bugs often manifest themselves as divergence in the control flow of processes compared to what was expected.
%
%In other words, HPC bugs violate the rule of ``symmetric'' and ``similar'' control flow of one or more threads/processes in typical HPC applications based on the original topology of the application.
%
%We believe that finding the dissimilarities among traces is the essential initial step towards locating the bug and identifying the root cause.

%Large-scale HPC application execution would result in thousands of PTs due to the execution of thousands of processes and threads.
%
%Since HPC applications spend most of their time in an outer main loop, every single PT also may contain sequences of millions of trace entries (i.e., function calls and returns).
%
%Finding the bug manifestation (i.e., dissimilarities caused by the bug) among a large number of long PTs is the problem of finding the needle in the haystack.

%
%Decompressing PTs collected from long-running large-scale HPC applications for offline analysis produces an overwhelming amount of data. However, missing any piece of collected data may result in losing key information about the application behavior.
%
%We propose a variation of the NLR (Nested Loop Recognition) algorithm \cite{Ketterlin-nlr} that takes a sequence of trace entries as input and, by recursively detecting repetitive patterns, re-compresses traces into ``iterative sets'' in a lossless fashion (intra-PT compression).  
%

%Analyzing the application execution as a whole (inter-PT compression) is another goal that we are pursuing in this work. 
%
%By extracting \textit{attributes} from pre-processed traces, we inject them into a concept hierarchy data structure called Concept Lattice \cite{clbook}.  
%
%Concept lattices give us the capability to reduce the search space from thousands of instances to just a few \textit{equivalence classes of traces} by measuring the similarity of traces \cite{Alqadah2011}, making the process of finding the needle in the haystack more feasible.
%
%Comparison of the bug-free concept lattice and its equivalent classes with the buggy version of the same application reveals insights about the dynamic behavior of the program and how the bug changed the classes and their members.
%

%Fowlkes et al.~\cite{fowlkes83} proposed a method for comparing two hierarchical clusterings by counting the objects that fall into the same or different clusters.
%
%Inspired by Fowlkes's approach, we believe that the PTs that fall into different classes before and after the bug are the potential PTs that manifest the bug impact and/or reflect the bug's root cause.
%
%These candidate PTs then require deeper \textit{observing} and \textit{diffing} with their corresponding bug-free PTs to see what has been changed when the bug was introduced.
%
\hl{**   TODO: 
Highlights of results obtained as a result of the above thinking should be here. This typically comes before ROADMAP of paper.}

In summary, this paper makes the following main contributions:
\begin{itemize}
\item A tunable tracing and trace-analysis tool-chain for HPC application program understanding and debugging
\item A variation of the NLR algorithm to compress traces in lossless fashion for easier analysis and detecting (broken) loop structures
\item An FCA-based clustering approach to efficiently classify traces with similar behavior
\item A tunable ranking mechanism to highlight suspicious trace instances for deeper study
\item A visualization framework that reflects the points of differences or divergence in a pair of sequences.
\end{itemize}

%
\hl{
The rest of the paper is as follows:

- Sec 2: Background

- Sec 3: Components

- Sec 4: Case Study: ILCS

- Sec 5: Related Work

- Sec 6: Concluding Remarks
}
