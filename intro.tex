
Detecting and root causing HPC bugs are expensive. While traditional software engineering often achieves high quality control, these methods are largely inapplicable to HPC where concurrency combined with problem-scale and the presence of very sophisticated domain-specific math makes programming really hard where, for example,  it takes months for a scientist to debug an MPI laser-plasma interaction code\cite{hpcdoe}.\\
HPC bugs manifest themselves differently based on the design and domain of application and platform the application is executing on. They are a function of both flawed program logic as well as unspecified and illegal interactions between various concurrency models ({\em e.g.}, PThreads, MPI, OpenMP, etc.) that coexist in any large application. Also HPC applications are usually heavy and consumes enormous amount of time and computation resources (energy). Reproducing bugs for such heavy applications by rerunning the application in case of execution failure is inefficient. The best hope for debugging in many cases lies in being able to efficiently capture detailed execution traces and compare them against traces emerging from previous (and more stable) software versions\cite{cstg}\cite{stat}. However, collecting informative data during the execution often needs source modifications and recompilation which often adds too much overhead to the actual application performance. \\
Thus the need of a generic low-overhead tracing tool that collects effective execution information dynamically and portable to multiple parallel platforms seems essential.
This paper offers \parlot, an efficient binary-level tracing tool that produce traces replete with debugging information that help locate a variety of possible bug types through offline trace analysis (without needing application reruns) if/when the application runs into an error. The mindset used here is \textit{“pay a little more upfront to dramatically reduce the number of overall debug iterations.”}. \parlot 's main contributions are:
\begin{itemize}
\item instrumenting the application binary and collects full function call trace in different levels with low overhead
\item employing advanced data compression methods to bring out traces across the memory hierarchy with dramatically reduced bandwidth needs
\item providing debuggers (humans and debugging tools) with traces that capture valuable full call-graph, even library calls, for every thread/process regardless of the execution platform.
\end{itemize}
The remainder of this paper is organized as follows. In section \ref{sec:bgreltool}, we introduce the basic ideas and infrastructures behind \parlot and similar existing tools. We describe the design of \parlot in Section \ref{sec:design}. Section \ref{sec:evalmeth} and \ref{sec:results} shows our evaluation of different aspects of \parlot and its comparsion with with one similar tool.

\subsection{Key strong points of \parlot from results}

\begin{itemize}
\item Low Tracing overhead - Table \ref{comet_sd_pMpAcg_BC_itn_p3.5} - Fig \ref{comet_chartAvg_sd_B_p3_5}, \ref{comet_chartAvg_sd_C_p3_5} - Section \ref{subsec:lowtoh}
\item Very low required bandwidth - Table \ref{comet_bw_pMpAcg_BC_itn_p3.5} - Fig \ref{comet_chartAvg_bw_B_p3_5}, \ref{comet_chartAvg_bw_C_p3_5} - Section \ref{subsec:lowbw}
\item Enormous amount of rich data can be reproduced from compressed trace sizes with very low required bandwidth - Table \ref{comet_cr_pMpA_BC_itn_p3.5} - Fig \ref{comet_chartAvg_cr_B_p3_5}, \ref{comet_chartAvg_cr_C_p3_5} - Section \ref{subsec:cr}
\item Majority of the overhead caused by Pin\_ init - Table \ref{comet_wo_det_All_all_B_p3.5}, \ref{comet_wo_det_Main_all_B_p3.5} - Fig \ref{comet_chartDet_B_wc_byTool_p3_5}, \ref{comet_chartDet_C_wc_byTool_p3_5} - Section: \ref{subsec:pinit}
\item \parlot without compression is terrible. (high impact of compression method on performance) - Table \ref{comet_wo_det_All_all_B_p3.5}, \ref{comet_wo_det_Main_all_B_p3.5}  - Fig \ref{comet_chartDet_B_woc_byTool_p3_5}, \ref{comet_chartDet_C_woc_byTool_p3_5} - \cite{subsec:compact}
\end{itemize}

