
\begin{itemize}
\item Why HPC Bugs matter?
	\begin{itemize}
	\item They are expensive:
		\begin{itemize}
		\item Expensive to reproduce because of non-determinancy of interleavings in HPC applications
		\item Expensive to reproduce in record-and-replay fashion
		\item Expensive for the non-parallel-programming-expert to find and solve the bug 
		\end{itemize}
	\item New bugs are introducing every day because of not well-known behavior of HPC applications:
		\begin{itemize}
		\item Heterogeneity: Disparities between processors, accelerators. memories and architectures.
		\item New unexplored scalable algorithms
		\item HPC applications are more domain-driven
		\end{itemize}
	\end{itemize}
\item Debugging HPC
	\begin{itemize}
	\item Challenges
		\begin{itemize}
		\item Diversity of HPC applications
		\item Applications are domain-specific 
		\item Bugs introduce/manifest itself in different situations
			\begin{enumerate}
			\item Designing application
			\item Modifying/optimizing applications
			\item Upscaling applications
			\item Using different compilers, compiler options and optimization flags
			\end{enumerate}
		\item In HPC debuggers, unlike traditional debuggers, there is no:
			\begin{enumerate}
			\item  Common benchmarks for driving verification tools
			\item Bug-repositories one can mine to improve one’s tools
			\item Thrusts of sharing bugs and building common solutions.				
			\end{enumerate}
		\item HPC applications are usually heavy. Collecting information and analysis of them are way heavier		 
		\end{itemize}
	\item Approaches
		\begin{itemize}
		\item Static Analysis
		\item Dynamic Analysis (Valgrind \cite{valgrind}, ARCHER \cite{archer})
		\item Formal Methods
		\item Tracing for Debugging (STAT \cite{stat}, CSTG \cite{cstg}
		\item Commercial Debugging (Allinea DDT \cite{ddt})
		\end{itemize}
	\item Problems with current state-of-the-art approaches
		\begin{itemize}
		\item They are domain specific
		\item Usually heavy-weighted and adds much overhead to native execution
		\item They are not all-purpose debuggers and targeting some specific type of bugs
		\item They are not composable
		\end{itemize}
	\item Our Approach
		\begin{itemize}
		\item \textbf{WHY?} Desire for a dynamic, scalable, portable, low-overhead and enough generative (not-domain specific or bug-specific) is essential in HPC applications.
		\item (From NSF proposal) Instead of developing a tool per problem or bug type, we seek a common way in which to present the debugging situation so that point-solution builders can easily plug their tools into our framework
		\item \textbf{Current paper}: [From Martin's section in NSF proposal] We developed an advanced tracing method that permit applications to be launched on a multi 100 --- petaflop platform with tracing enabled from the get--- go. The mindset used here is \textit{“pay a little more upfront to dramatically reduce the number of overall debug iterations.”}. We will aim to produce traces replete with debugging information that help locate a variety of possible bug types through offline trace analysis (without needing application reruns) if/when the application runs into an error. To minimize application slowdown, we  developed advanced methods to compress traces so that their movement across the memory hierarchy becomes acceptably efficient. In contrast to all of this, in today’s approaches, failing applications must be rerun from scratch, each time with the goal of looking for a few bug classes. The tracing in such runs narrowly focuses on the bug types being searched for. Thus, multiple tracing runs are needed, consuming valuable compute resources. Also, we know of no actively used debugging methods that employ advanced compression methods.
		\end{itemize}
	\end{itemize}
\end{itemize}



[From now on, this is old version of Introduction for our IPDPS attempt]
The act of rendering any software design into code invariably
introduces bugs.
%
The code is tested till it stops readily revealing bugs, and then it is
put into production.
%
The remaining lurking bugs often remain dormant, but
rear their head when the inputs are changed or the code
is ported to new platforms.
%
While traditional software engineering often achieves high
quality control, these methods are largely inapplicable to HPC
where concurrency combined with problem-scale and the
presence of very sophisticated domain-specific math
makes programming really hard.
%
Good quality HPC software almost always requires extremely skilled
developers.
%
Unfortunately, good developers are rare, and the need to deploy HPC software
only keeps growing, thus putting a lot of burden on the shoulders of those
who still are maturing.
%
The only solution is that debugging tools must begin doing far more heavy lifting
than traditionally expected.


In HPC, bugs are a function of both flawed program logic as well as unspecified
and illegal interactions between various concurrency models ({\em e.g.}, PThreads,
MPI, OpenMP, etc.) that coexist in any
large application.
%
The best hope for debugging in many cases
lies in being able to efficiently capture detailed execution
traces and compare them against traces emerging from previous (and more stable) 
software versions.
%
This paper offers ParLot, an efficient binary-level tracing tool that 
(1)~traces compiled applications with very little overhead, (2)~employs
advanced data compression methods to bring out traces across the memory
hierarchy with dramatically reduced bandwidth needs, and (3)~provides debuggers
(humans and debugging tools) with traces that capture many valuable pieces of
information such as function call/return chains, function call frequencies, and
the total number of various instruction types executed.
%
The shocking thing is that despite being at the threshold of exascale computing,
the community does not have a tracing tool that has anywhere near the level
of efficacy that ParLot has.


This paper itself does not propose debugging methods.
%
Instead, the purpose of this paper is to really take stock of what else is
available for tracing and debugging large-scale applications, and perform 
a fairly thorough evaluation of their capabilities vis-a-vis ParLot.
%
Thus, we aim to scientifically establish that we indeed have solved the
tracing problem better than anyone else has.
%
We then appeal to past work (some of it being our own past successes) showing that we now are in
a position to breathe new life into such tracing-based debugging tools, now that
ParLot will be able to efficiently provide trace information to them.

Here are the main contribution of this paper:
\begin{itemize}
\item Tracing
\item Compression
\item Stack correction
\end{itemize}

The remainder of this paper is organized as follows. In section
\ref{sec:background}, we introduce the basic ideas and infrastructures behind ParLot. Section \ref{sec:reltools} describes existing tracing tools and techniques and their relevance
to our approach. We present the implementation of Parlot in Section \ref{sec:impl}. Section \ref{sec:evalmeth} and \ref{sec:results} shows our evaluation of different aspects of \parlot and its comparsion with \callgrind.
