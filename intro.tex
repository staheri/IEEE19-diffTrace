\begin{itemize}
\item HPC Bugs are expensive
\item HPC Tracing is expensive
\item ParLOT provides infrastructure for whole-program function call return tracing
\item Decompressing traces produce large amount of data
\item Smart analysis of traces, convert large amount of data from thousands of traces (processes, threads) into a valuable information which are
	\begin{itemize}
	\item Easy to analyze
	\item hide the complexity of HPC
	\item Reflect dynamic behavior of the program
	\item see if it matches the user/developer expectations
	\end{itemize}
\item The basic idea is to reduce the search space and reflect abnormal behavior by:
	\begin{itemize}
	\item Classifying similar behavior traces into equivalent classes
	\item Comparing representatives from equivalent classes and find the point of divergence (i.e., diffing)
	\end{itemize}
\item Here are the contributions:
	\begin{itemize}
	\item Testing framework (diffTrace) from fault injection to large-scale applications to diffing pairs of candidate trace files causing the fault. (clTrace and fpTrace)
	\item MPI fault injection
	\item ParLOT trace Collection
	\item Trace Preprocessing (decompression, loop detection, attribute extraction)
	\item Concept Lattice, Jaccard Similarity Matrix, Trace classification, outlier detection
	\item Diffing
	\item Floating Point Debugging
	\end{itemize}
\end{itemize}
