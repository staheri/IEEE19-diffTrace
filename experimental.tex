
ILCS is a scalable framework for running iterative local searches on HPC platforms.
%
Providing a serial CPU or single-GPU code, ILCS then executes this code in parallel between compute nodes (MPI) and within them (OpenMP and multi-GPU).
%

To evaluate the effectiveness of ideas behind DiffTrace, we have manually injected MPI-level and OMP-level bugs to the Traveling Salesman Problem (TSP) implementation on ILCS framework (Listing~\ref{lst:ilcs}).
%

The injected bugs are tend to simulate real bugs such as deadlock.
%
Also bugs are close to common mistakes that HPC developers usually make during developing HPC codes. In addition, there exist ``hidden'' faults that does not alarm anything during execution such as violation of critical sections or semantic-based bugs. 
%

\input{tabs/ilcsPseudoCode-compact.tex}

The injected bugs are planted in a way that might get triggered in only one or more threads (master and worker threads, one thread, every other thread, all threads except one, all threads). 
%
Generally, the goal is to see how effective DiffTrace can analyze and diff traces, and how close it can get to the fault root cause or its manifestation. 

%
We have collected ParLOT (main image) traces from the execution of ILCS-TSP with 8 MPI processes and 4 OpenMP threads on each process. \hl{PSC Config will be added}

Note that the GPU-related activities of ILCS are out of the scope of this paper, and we have not touched them in our experiments.
%


\subsection{ILCS-TSP workflow}

\hl{2-3 sentences about how ILCS finds local champions in TSP problem}

There are two types of threads in ILCS: a \textit{master} thread per node (MPI process) and a set of \textit{worker} threads per compute node (OpenMP threads).
%
Master threads of compute nodes are in charge of handling local working threads and communicating with master threads on other nodes.
%
For each detected CPU core, the master thread forks worker OpenMP threads.
%
Each worker thread continually calls
\texttt{CPU\_Exec()} to evaluate a range of seeds and record the results (lines 14-20).
%
Once the worker threads are running, the master thread's primary job is to scan the results of the workers to find the best solution computed so far (i.e., the local champion). This information is then globally reduced to determine the current system-wide champion (lines 22-32).
%
Since scanning the entire seed range in a reasonable amount of time is not feasible, ILCS terminates the search when the quality has not improved over a certain period (lines 33-34).

\subsection{OpenMP Bug: Unprotected Memory Access}


\input{tabs/mc1-mc-6-4.tex}


The memory accesses of \texttt{memcpy} in line 20 and 30 are protected by OpenMP critical section.
%
If under some scenario, this shared memory location becomes unprotected, a race condition might happen and invalidate the ILCS final output.
%
We have simulated such a scenario and modified the ILCS source code so that the control flow of the program skip the critical section in some specific OpenMP threads.
%
In one case where we inject this bug to the worker thread 4 of process 6, DiffTrace generated Table~\ref{tab:mc1-mc-6-4} as top suspicious traces for further analysis.
%
Each table entry contains the parameter that leads to the last two column suggestions.
%
For example, filter ``11.mem.ompcit.cust.0K10'' briefly means that all returns and .plt calls have been removed from traces of both faulty and normal executions, and only memory-related functions, OpenMP critical section functions and custom function ``CPU\_Exec'' are kept in traces.
%
The K10 at the end of filter means that all filtered traces are converted to their equivalent NLR with $K$=10.
%
The rest of the parameters have been explained in previous sections.
%

The bold numbers in the last column are suggesting trace \textbf{6.4} (process 6, thread 4) as the trace that changed the most after we planted the bug.
%
diffNLR(6.4) in Figure~\ref{diffNLR-6-4} clearly shows that the normal execution of ILCS (blue blocks) protects the \texttt{memcpy} while the buggy execution does not. In this figure, L0 is \texttt{CPU\_Exec}, which has been executed several times in both versions but never reaches the optimal solution until the end.
%


\begin{figure}[]
\centering
\includegraphics[width=0.3\textwidth]{figs/diffNLR/ompBug-6-4.pdf}
\caption{OpenMP Bug: diffNLR(6.4)}
\label{diffNLR-6-4}
\end{figure}

\subsection{MPI Bug: Deadlock Caused by Fault in Collectives}
By forcing only one of the processes (process 2) to invoke MPI\_Allreduce (line 24) with a wrong size, we have simulated a \textit{real deadlock}. 
%
Table~\ref{tab:ar1-ws-all-nn} shows that almost all processes are suspicious.
%
It turned out that ParLOT did not happen to capture function calls from all processes since the bug happens too early in the code. Thus except for process 1 and 4, all other traces are empty.
%
By looking at the diffNLR(1) (Figure~\ref{diffNLR-0}), we can see that both normal and the buggy trace of process $1$ identical until an invocation of MPI\_Allreduce(). After that, normal trace hits the end of the program and terminates while the buggy process is waiting for the return from the actual point of fault (process 2) and never ends (i.e., deadlocks). 
%
diffNLRs of other processes look the same.
%
This is the situation that a bug in one process manifests itself all over the 
\input{tabs/ar1-ws-all-nn.tex}

\begin{figure}[]
\centering
\includegraphics[width=0.3\textwidth]{figs/diffNLR/mpiBug-all-nn.pdf}
\caption{diffNLR(0)}
\label{diffNLR-0}
\end{figure}
%



\subsection{MPI Bug: Wrong Collective Operation}
By changing the operation MPI\_MIN to MPI\_MAX in the input arguments of MPI\_Allreduce(), we have changed the semantics of ILCS. 
%
The execution of this variation terminated well, but the results might be corrupted.
%

The MPI\_Allreduce() in line 24 of Listing~\ref{lst:ilcs} broadcasts the best-calculated answer among all processes.
%
However, by the change that we made to ILCS, now the ``worst'' answer is getting stored.
%
We injected the bug only to process 0.
%
Among all suggested suspicious processes (Table~\ref{tab:ar1-wo-0-nn}), only process 5 (bold numbers) are making sense since their filters are more relevant to the aspect that we are interested (MPI-level activities) to study deeper.
%
Our observation from diffNLR(5) (Figure~\ref{diffNLR-5}) is that process 5, in comparison with its corresponding normal process, involves more in updating and broadcasting the champion among all traces.
%
Similar to the deadlock bug, this is another instance of  ``bug manifestation'' detection by DiffTrace.

\input{tabs/ar1-wo-0-nn.tex}

\begin{figure}[]
\centering
\includegraphics[width=0.3\textwidth]{figs/diffNLR/mpiBug2-0-nn.pdf}
\caption{diffNLR(5)}
\label{diffNLR-5}
\end{figure}


