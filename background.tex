
\subsection{Binary Instrumentation}
Recording a log of events during the execution of an application is essential for better understanding of the behavior of the program and, in case of a failure, to locate the problem. Recording this type of information requires instrumentation of the code either at the source-code or binary-code level. Instrumenting the source code is easier for developers but not for users since developers can add specific pieces of code to certain points of the source code to collect the needed information. But it requires modification of the source code and recompilation, which make it more difficult and less straight-forward for users. In addition, binary instrumentation makes the process of tracing language independent and portable. It also provides machine-level insight of the behavior of the application.


Binary codes can be instrumented \textit{statically} [static binary tool], where the additional code is inserted into the binary before execution, which results in a persistent modified executable, or \textit{dynamically}, where the modification of the executable is not permanent. In dynamic binary instrumentation, code can be discovered at runtime, making it possible, for example, to handle dynamically-generated and self-modifying code. Furthermore, it may be possible to attach the instrumentation to running processes, which is particularly useful for long-running applications.
Different application behavior investigator tools had been designed on top of Dynamic Binary Instrumentation (DBI) frameworks.


Dyninst\cite{dyninst} is a dynamic instrumentation API which gives developers the ability to measure the performance like Open-SpeedShop\cite{openss} and TAU\cite{tau} and develop correctness debuggers like STAT \cite{stat}. VampirTrace\cite{vampirt} uses Dyninst API to provide a library for collecting logs from program execution. 

Valgrind\cite{valgrind} is shadow value DBI framework that maps and records every register and memory value. It gives developers the capability of instrumenting system calls and instructions. Error detectors such as Memcheck\cite{memcheck} and call-graph generator like \callgrind\cite{callgrind} have been built on top of Valgrind.

We designed \parlot on top of \pin\cite{pin}, a dynamic binary instrumentation framework for the IA-32, x86-64, and MIC instruction-set architectures that enables the creation of dynamic program analysis tools. \parlot mutates \pin to track the function call stack and captures every entry (call) and exit (return) of every function and build the full trace with stack correction(more in section \ref{sec:design}).\\

\subsection{Efficient Tracing for Debugging}
When dealing with large-scale parallel programs, any attempt to generate traces will likely result in a huge amount of data. Moreover, such tracing will also incur significant overhead due to the need to transfer and store the vast amount of data. For example, collecting just one byte of information per executed instruction generates on the order of a gigabyte of data per second on a single high-end core.  Storing the resulting multi-gigabyte traces from many cores can be a challenge, even on today's large hard disks.

Hence, we need a way to decrease the space and runtime overhead. A compression mechanism to encode the generated data into a smaller number of bits makes transmitting and storing more efficient. Although every encoded data needs to be decoded for analysis, compressing and encoding the trace data while it is being collected enable us to gather much more information.

The idea of compressing large-scale  traces have been used in \cite{eventflowgraph} for compressing performance traces and in ScalaTrace\cite{scalatrace} where it uses reptetive nature of timestep simulation in parallel scientific applications to compress traces\cite{freitag}. Only small fraction of compression is happening on-fly and the focus is on reducing inter-node communication. 

In \parlot, the traced information is incrementally compressed while the application is running, typically resulting in just a few kilobytes of data needing to be written per thread and per second.
The traces are decompressed later (at no additional cost to the  execution of the application). From the decompressed full function-call trace, the complete call graph, the function call frequency, and the caller-callee relations can be extracted. This can be done at the granularity of a thread, group of threads, or the whole application. 
Tools like TAU\cite{tau} and Score-p\cite{scorep} have been using the idea of tracing and compressing traces for performance analysis of parallel-based applications. STAT\cite{stat} is one of the very few tools that is designed based on execution tracing approach for debugging purposes. After gathering function call traces during execution, STAT groups the processes with similar function-call stack and trying to find abnormal behavior like divergence in the function call-graph by delta debugging.

