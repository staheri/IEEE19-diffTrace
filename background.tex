
\subsection{PIN}
Recording a log of events during the execution of an application is essential for better understanding of the behavior of the program and, in case of a failure, to locate the problem. Recording this type of information requires instrumentation of the code either at the source-code or binary-code level. Instrumenting the source code is easier for developers but not for users since developers can add specific pieces of code to certain points of the source code to collect the needed information. But it requires modification of the source code and recompilation, which make it more difficult and less straight-forward for users. In addition, binary instrumentation makes the process of tracing language independent and portable. It also provides machine-level insight of the behavior of the application. Binary codes can be instrumented \textit{statically}, where the additional code is inserted into the binary before execution, which results in a persistent modified executable, or \textit{dynamically}, where the modification of the executable is not permanent. In dynamic binary instrumentation, code can be discovered at runtime, making it possible, for example, to handle dynamically-generated and self-modifying code. Furthermore, it may be possible to attach the instrumentation to running processes, which is particularly useful for long-running applications.

We designed ParLOT on top of PIN [??], a dynamic binary instrumentation framework for the IA-32, x86-64, and MIC instruction-set architectures that enables the creation of dynamic program analysis tools. During execution, ParLOT tracks the function call stack and captures every entry (call) and exit (return) of every function. ParLOT not only captures the functions of the main image but also in library code.


\subsection{Compression}
When dealing with large-scale parallel programs, any attempt to generate traces will likely result in a huge amount of data. Moreover, such tracing will also incur significant overhead due to the need to transfer and store the vast amount of data. For example, collecting just one byte of information per executed instruction generates on the order of a gigabyte of data per second on a single high-end core.  Storing the resulting multi-gigabyte traces from many cores can be a challenge, even on today's large hard disks.

Hence, we need a way to decrease the space and runtime overhead. A compression mechanism to encode the generated data into a smaller number of bits makes transmitting and storing more efficient. Although every encoded data needs to be decoded for analysis, compressing and encoding the trace data while it is being collected enable us to gather much more information.

In ParLOT, the traced information is incrementally compressed while the application is running, typically resulting in just a few kilobytes of data needing to be written per thread and per second.
The traces are decompressed later (at no additional cost to the  execution of the application). From the decompressed full function-call trace, the complete call graph, the function call frequency, and the caller-callee relations can be extracted. This can be done at the granularity of a thread, group of threads, or the whole application. 
