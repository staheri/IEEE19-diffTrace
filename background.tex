There are two major phases in any ``Program Understanding'' tool: \textit{data collection} and \textit{data analysis}.
%
To understand the runtime behavior of applications, an efficient tracing mechanism is required to collect informative data during execution of the application.
%
ParLOT collects whole program function call traces with the mindset of \textit{paying a little upfront and save resource and time cost of reproducing the bug}.

- detection of loops, lossless Compression, easier to analyze, information about loop structures, how many iteration each loop executed matters, broken loop matters

- Concept lattices, throw inter-process information, similarity, clustering

- diffNLR visualizes pairs of traces and reflect their differences where they are supposed to be equal. 


%TODO: The story builds on powerful components we have created. 

% Binary tracing
\subsection{Parlot Summary (changeme)}

- why binary instrumentation? no need to modify the code to instrument - no need to recompile, unlike most of HPC tools (performance tools like TAU\cite{tau}, Score-p\cite{scorep} and debugging tools like STAT\cite{stat} and AutomaDeD\cite{automaded-laguna} that requires Dyninst\cite{dyninst} for instrumentation and MRNet\cite{mrnet} and TBON \cite{tbon})

To overcome the trade-off of comprehensive data collection while adding low time and space overhead, HPC program analysis tools often sacrifice one for the other. However, ParLOT collects whole-program function call traces at as low as library level, while incrementally compressing traces on-the-fly and leave majority of the system bandwidth for the application. 

Each ParLOT Trace (PT) contain full sequence of function calls and returns for every single thread that running the application code, reflecting the dynamic control flow and call-stack of the application.


 
% CLs
\subsection{Equivalencing behavior via concept lattices (changeme)}

this is how it is cleanly defined (use our context or examples)

e.g. high-level : objects to attributes

in our case objects can be... and attributes can be

how we use them is ...


\begin{itemize}
\item Vijay Garg - Applications of lattice theory in distributed systems

\item Dimitry Ignatov \cite{ignatov} - Concept Lattice Applications in Information Retrieval

\item \cite{clbook} \cite{clconst} \cite{bender05} \citep{latticeForDistConst} 

Similarity measurement using FCA \cite{Alqadah2011}
\end{itemize}



\subsubsection{Attribute creation...}

There are many of them (others have not 

\subsubsection{incremental algos}

challenges : need incremental algo...

end




% NLRs
\subsection{Loop structure detection}

loop detection has been addressed in xyz

challenges in our context are xyz...

highlights of what you did (briefly) and why it can help

\subsection{diffing (changeme)}


what you adapted

how does it help

\cite{diff-myers}

\clearpage

\subsection{STAT}

Parallel debugger STAT\cite{stat}
\begin{itemize}
\item STAT gathers stack traces from all processes
\item Merge them into prefix tree
\item Groups processes that exhibit similar behavior into equivalent classes
\item A single representative of each equivalence can then be examined with a full-featured debugger like TotalView or DDT
\end{itemize}

What STAT does not have?

\begin{itemize}
\item FP debugging
\item Portability (too many dependencies)
\item Domain-specific
\item Loop structures and detection
\end{itemize}
 

\subsection{Program Understanding }



\begin{itemize}
\item Score-P \cite{scorep}
\item TAU \cite{tau}
\item ScalaTrace: Scalable compression and replay of communication traces for HPC  \cite{scalatrace}
\item Barrier Matching for Programs with Textually unaligned barriers \cite{zhang07}
\item Pivot Tracing: Dynamic causal monitoring for distributed systems - Johnathan mace \cite{pivot}
\item Automated Charecterization of parallel application communication patterns \cite{roth-15}
\item Problem Diagnosis in Large Scale Computing environments \cite{miller06}
\item Probablistic diagnosis of performance faults in large-scale parallel applications \cite{laguna-12}
\item detecting patterns in MPI communication traces - robert preissl \cite{preissl-08}
\item D4: Fast concurrency debugging with parallel differntial analysis - bozhen liu \cite{liu-18}
\item Marmot: An MPI analysis and checking tool - bettina krammer \cite{marmot}
\item MPI-checker - Static Analysis for MPI - Alexandrer droste \cite{mpi-checker}
\item STAT: stack trace analysis for large scale debugging - Dorian Arnold \cite{stat}
\item DMTracker: Finding bugs in large-scale parallel programs by detecting anomaly in data movements \cite{dmtracker}
\item SyncChecker: Detecting synchronization errors between MPI applications and libraries - \cite{syncChecker}
\item Model Based fault localization in large-scale computing systems - Naoya Maruyama \cite{satoshi-08}
\item Synoptic: Studying logged behavior with inferred models - ivan beschastnikh \cite{beschastnikh-synoptic}
\item Mining temporal invariants from partially ordered logs -  ivan beschastnikh \cite{beschastnikh-pologs}
\item Scalable Temporal Order Analysis for Large Scale Debugging - Dong Ahn \cite{Ahn:2009}
\item Inferring and asserting distributed system invariants -  ivan beschastnikh - stewart grant \cite{grant18}
\item PRODOMETER: Accurate application progress analysis for large-scale parallel debugging - subatra mitra \cite{prodometer}
\item Automaded : Automata-based debugging for dissimilar parallel tasks - greg \cite{automaded-GBron}
\item Automaded : large scale debugging of parallel tasks with Automaded - ignacio \cite{automaded-laguna}

\item Inferring models of concurrent systems from logs of their behavior with CSight - ivan \cite{beschastnikh-csight}
\end{itemize}




\subsection{Trace Analysis}


\begin{itemize}
\item Trace File Comparison with a hierarchical Sequence Alignment algorithm \cite{weber-seqAlign}
\item structural clustering : matthias weber \cite{weberStructural}
\item building a better backtrace: techniques for postmortem program analysis - ben liblit \cite{liblit02}
\item automatically charecterizing large scale program behavior - timothy sherwood \cite{sherwood02}
\end{itemize}


\subsection{Visualizations}


\begin{itemize}
\item Combing the communication hairball: Visualizing large-scale parallel execution traces using logical time - katherine e isaacs \cite{ravel}
\item recovering logical structure from charm++ event traces \cite{charmVis}
\item ShiViz - Debugging distributed systems - \cite{shiviz}
\end{itemize}



\subsection{Concept Lattice and LCA}


\begin{itemize}
\item Vijay Garg - Applications of lattice theory in distributed systems

\item Dimitry Ignatov \cite{ignatov} - Concept Lattice Applications in Information Retrieval

\item \cite{clbook} \cite{clconst} \cite{bender05} \citep{latticeForDistConst} \cite{diff-myers}
\end{itemize}

\subsection{Repetitive Patterns}


\begin{itemize}
\item \cite{kmruse} \cite{kmr} \cite{nakamura_fast_2013} \cite{crochemore_jewels_2002} \citep{Crochemore:1994:TA:199269}
\end{itemize}


