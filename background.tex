There are two major phases in any ``Program Understanding'' tool: \textit{data collection} and \textit{data analysis}.
%
To understand the runtime behavior of applications, an efficient tracing mechanism is required to collect informative data during execution of the application.
%
Upon failure or observing unexpected behavior of the program (e.g., wrong answer), studying collected execution data would reveal insight about how program dynamically behaved and what went wrong.
%
In this section, we explain our methodology of data collection and data analysis towards debugging and locating potential root causes of unexpected behavior.
%
ParLOT collects whole program function call traces with the mindset of \textit{paying a little upfront and save resource and time cost of reproducing the bug}.

[[ToBeADDED to the background story]]:

- Nested Loop Recognition (NLR): Easier to analyze, information about loop structures, how many iteration each loop executed matters, broken loop matters

- Concept lattices, inter-process information, similarity, clustering, efficient, scalable, can be used as execution model, can be used in machine learning, can be used to extract HB relation in events.

- diffNLR visualizes pairs of traces and reflect their differences where they are supposed to be equal. 


%TODO: The story builds on powerful components we have created. 

% Binary tracing
\subsection{Parlot Summary (changeme)}
The final executable of real HPC applications are often a production of a large code base and a complex build system with numerous dependencies and libraries. Injecting instrumentation code to source code, as in traditional tools like [????], is not feasible in HPC space. Also recompilation of the application with tools` compile-wrappers, as in TAU\cite{tau} and Score-p\cite{scorep}, may break the build system. 
Also instrumentation and tracing mechanism of existing tools are often dependent to other libraries that are need to be present on the supercomputer for trace collection. [[ Example: STAT\cite{stat} and AutomaDeD\cite{automaded-laguna} that requires Dyninst\cite{dyninst} for instrumentation and MRNet\cite{mrnet} and TBON \cite{tbon}]]

To overcome the trade-off of comprehensive data collection while adding low time and space overhead, HPC program analysis tools often sacrifice one for the other. However, ParLOT collects whole-program function call traces at as low as library level, while incrementally compressing traces on-the-fly and leave majority of the system bandwidth for the application. 

Each ParLOT Trace (from now on in this paper, PT refers to \textit{single ParLOT Trace}) contain full sequence of function calls and returns for every single thread that running the application code, reflecting the dynamic control flow and call-stack of the application.

% CLs
\subsection{Equivalencing behavior via concept lattices (changeme)}

this is how it is cleanly defined (use our context or examples)

e.g. high-level : objects to attributes

in our case objects can be... and attributes can be

how we use them is ...


\begin{itemize}
\item Vijay Garg - Applications of lattice theory in distributed systems

\item Dimitry Ignatov \cite{ignatov} - Concept Lattice Applications in Information Retrieval

\item \cite{clbook} \cite{clconst} \cite{bender05} \citep{latticeForDistConst} 

Similarity measurement using FCA \cite{Alqadah2011}
\end{itemize}



\subsubsection{Attribute creation...}

There are many of them (others have not 

\subsubsection{incremental algos}

challenges : need incremental algo...

end




% NLRs
\subsection{Loop structure detection}

loop detection has been addressed in xyz

challenges in our context are xyz...

highlights of what you did (briefly) and why it can help

\subsection{diffing (changeme)}


what you adapted

how does it help

\cite{diff-myers}
