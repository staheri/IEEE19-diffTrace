\subsection{Original from latest HPDC draft}
In this paper, we introduced \parlot, a portable low overhead dynamic
binary instrumentation-based
tracing tool that can help with incise debugging of parallel applications.
%
The traces that \parlot produces are sufficiently informative that
a variety of debugging methods can be brought to bear on the
(efficiently collected) traces.
%
Key properties of \parlot include its on-the-fly trace collection and
compression (which reduces timing jitter), a plethora of information
about function calls and returns (with automatic stack-pointer 
correction for inlined binaries and non-standard returns), and
significantly better compression efficiencies.
%
The traces generated by
\parlot  contain enough information to help programmers debug
tricky corner cases that involve reasoning about function call/return
patterns.
%
The collected traces cut through the entire stack of heterogeneous
(MPI, OpenMP, PThreads) calls; thus, if a designer filters such traces
and projects them onto specific calls of interest, they would be in 
a position to minutely study and locate issues.


In this paper, we present an evaluation of various tool versions of \parlot
(created by disabling/enabling compression, not collecting any traces but
merely performing initialization), etc.
%
We also compare \parlot against \callgrind, a somewhat comparable tool
in this space.
%
Our evaluation criteria cover tracing overhead, the required bandwidth,
the achieved compression ratio, initialization overhead, and the 
overall impact of compression.
%
These detailed evaluations on the NAS parallel benchmarks running on
up to 1024 cores establishes the merit of our tool and our design
decisions.


A number of improvements to \parlot remain to be made.
%
These include allowing users to selectively trace at specific
interfaces: doing so can further increase compression efficiency
by reducing the variety of function calls to be treated by
the compressor.
%
We also discuss the need to bring down initialization overheads, say
by switching to a less general-purpose tool in this space.
%
Last but not least, it would be good to apply similar methods to
other CPUs and GPUs that come with binary instrumentation and tracing
facilities similar to PIN.


Last but not least, we must now begin employing \parlot for its
intended purpose: debugging actual large HPC applications.
%
We are  building a framework for doing this study by building
a fault injection facility and ways to further elevate the
status of the collected traces by equivalencing similar behaviors
and looking for outlier exections.

%--end

\ignore{--
\subsection{NEW FOR ICPP}

\subsubsection{Debugging Story}

General Outline:

\begin{itemize}
\item Using PMPI, I injected some simple bugs to three MPI applications:
	\begin{itemize}
	\item Integral
		\begin{itemize}
		\item MPI-Allgather() : Wrong Receive Count
		\item MPI-Allgather() : Wrong Send Count
		\item MPI-Allgather() : Wrong Root ID
		\end{itemize}
	\item Eratosthenes
		\begin{itemize}
		\item MPI-Reduce) : Wrong  Count
		\item MPI-Reduce() : Wrong Root ID
		\end{itemize}
	\item ILCS (Broadcast - to be added)
	\end{itemize}
\item Generated traces(from main image and all images) during execution with 8 processes.
\item Generated triples <Object, Attributes,Relation> from traces for Concept Lattice Construction. Here are the attribute sets I extracted from each trace (after decompression):
	\begin{itemize}
	\item \textbf{B0} - Set of all function calls (regardless of their frequency or order of invoking)
	\item \textbf{B1} - A set containing of pairs of $<function\_name,frequency\_bins>$\\
	$freq\_bin(function) = Log_\text{10}freq$
	\item \textbf{B2} - A set containing of pairs of $<function\_name,frequency\_bins>$\\
		$freq\_bin(function) = (-1) * Log_\text{10}(freq/totalLength)$
	
	\end{itemize}
\item I have designed a mechanism to split the sequence of traces at points of interests. Here are the list of different chunks of traces:
	\begin{itemize}
	\item \textbf{Full}: This chunk is the full length trace. In some applications during execution, extra threads had been forked thus ParLOT generates traces for them as well. \textbf{Full} concatenates the traces from all threads in order starting from thread 0.
	\item \textbf{Collective}: Split trace at collective/barrier
	\item \textbf{Internal Bugged}: The sequence of all internal function invocations of the MPI function that I injected bug to.
	\item \textbf{Threads}: Split trace at beginning of each thread.
	\end{itemize}
\end{itemize}
By comparing these chunks for different attribute sets and buggy-vs-bugFree traces and CLs, we can see significant differences (bug manifests).
--}