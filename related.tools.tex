Instrumenting, profiling and tracing large-scale applications have become more popular to researchers and companies [ddt] due to high demand of HPC users. 
Dyninst\cite{dyninst} is a dynamic instrumentation API which gives developers the ability to measure the performance \cite{openss}\cite{tau} and develop correctness debuggers \cite{stat}. It instruments the binary without any need of recompilation and also gives the developer the ability to attach instrumentation to a running process. VampirTrace\cite{vampirt} also uses Dyninst API to provide a library for collecting logs from program execution. 

The idea of analyzing execution traces for debugging purposes have been used in STAT\cite{stat} where it groups the processes with similar function-call stack and trying to find abnormal behavior like divergence in the function call-graph by delta debugging. The idea of tracing for debugging purposes have been used in other tools but first of all the overhead they add to the target application is high and are not straight-forward for HPC users who might not be a developer. They either need static instrumentation by inserting code-snippets and macros, or/and recompilation of the source code. 
Valgrind\cite{valgrind} is shadow value DBI framework that maps and records every register and memory value. It gives developers the capability of instrumenting system calls and instructions. Many error detectors such as Memcheck \cite{memcheck} have beeen built on top of Valgrind. Callgrind \cite{callgrind} is a profiling tool  on Valgrind platform that records the call history among functions in a program's run as a call-graph by measuring the number of instructions executed and their relationship to source lines. Our experiments (section \ref{sec:res}) shows that Callgrind adds up to ??? overhead to the target application to collect just the call-graph while generating huge trace files without any compression applied.

and  \cite{ipm} \cite{tau} \cite{scorep} \cite{vtune}

The idea of compressing large-scale  traces have been used in \cite{event-flow-graph} for compressing performance traces and in ScalaTrace\cite{scalatrace} where it uses reptetive nature of timestep simulation in parallel scientific applications to compress traces[\cite{freitag}]. Only small fraction of compression is happening on-fly and the focus is on reducing inter-node communication. 